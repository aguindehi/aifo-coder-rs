stages:
  - pre
  - build
  - test
  - release

include:
  - component: $CI_SERVER_FQDN/devops-services-public/infrastructure-as-code/cicd-components/container/build@0.18
    inputs:
      image_tag_custom: $CI_COMMIT_SHA

variables:
  PACKAGE_REGISTRY_URL: ${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/${CI_PROJECT_NAME}/${CI_COMMIT_TAG}
  # Local-only macOS signing: optional upload location for signed/notarized per-arch zips.
  # These are produced on macOS with:
  #   make release-macos-binary-signed
  # and then uploaded to the GitLab Generic Package Registry under:
  #   ${CI_PROJECT_NAME}/${CI_COMMIT_TAG}/
  #
  # Expected filenames are versioned to avoid collisions:
  # - aifo-coder-${CI_COMMIT_TAG}-macos-arm64.zip
  # - aifo-coder-${CI_COMMIT_TAG}-macos-x86_64.zip
  SIGNED_MACOS_ARM64_ZIP: aifo-coder-${CI_COMMIT_TAG}-macos-arm64.zip
  SIGNED_MACOS_X86_64_ZIP: aifo-coder-${CI_COMMIT_TAG}-macos-x86_64.zip
  KEEP_APT: "0"
  DOCKER_BUILDKIT: "0"

# Workflow

workflow:
  rules:
    # Allow scheduled pipelines (e.g., nightly builder refresh)
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: always

    # Prefer merge request pipelines for branches with MRs
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: always

    # Suppress branch-push pipelines when an MR exists for the branch
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_OPEN_MERGE_REQUESTS
      when: never

    # Allow normal branch pushes when no MR exists
    - if: $CI_PIPELINE_SOURCE == "push"
      when: always

    # Always allow tag pipelines
    - if: $CI_COMMIT_TAG
      when: always

# Rules

.rules_build_image: &rules_build_image
  - if: $CI_COMMIT_TAG

# Base job provided as cicd-component by the cloud team. Used as template and should not run on its own
container-build:
  variables:
    #TARGET: Has to be provided by a child job. Defines the name of the target container within the Dockerfile.
    KANIKO_CACHE_ARGS: "--cache=true --cache-ttl=168h --cache-repo $CI_REGISTRY_IMAGE/kaniko-cache"
    IMAGE_PREFIX: "coder"
    IMAGE_TAG_CUSTOM: $CI_COMMIT_TAG
    IMAGE_TAG_CUSTOM_ONLY: true
  before_script:
    - |
      IMAGE_PATH_EXTRA="aifo-${IMAGE_PREFIX}-${IMAGE_PATH_EXTRA:-$TARGET}"
      # Use time-based snapshotting to reduce Kaniko memory usage
      KANIKO_BUILD_OPTIONS="--snapshotMode=time --use-new-run"
      # Rely on Kaniko --use-new-run to support BuildKit RUN semantics:
      # - RUN --mount=type=secret (supported)
      # - RUN --mount=type=cache (supported)
      # Keep shared Dockerfiles Kaniko-safe: avoid COPY --link/--chmod.
      # Rely on Kaniko --use-new-run to support BuildKit RUN semantics:
      # - RUN --mount=type=secret (supported)
      # - RUN --mount=type=cache (supported)
      # Keep shared Dockerfiles Kaniko-safe: avoid COPY --link/--chmod.
      # Rely on Kaniko --use-new-run to support BuildKit RUN semantics:
      # - RUN --mount=type=secret (supported)
      # - RUN --mount=type=cache (supported)
      # Keep shared Dockerfiles Kaniko-safe: avoid COPY --link/--chmod.
      # If TARGET_NAME or TARGET is provided, add --target attribute to build
      [ -n "${TARGET_NAME:-$TARGET}" ] && KANIKO_BUILD_OPTIONS="${KANIKO_BUILD_OPTIONS} --target ${TARGET_NAME:-$TARGET}"
  rules: # Turn off component rules
    - if: $CI_COMMIT_BRANCH == "never"
      when: never

# Pre stage: cancel redundant branch pipeline when MR pipeline starts

cancel-branch-pipeline:
  stage: pre
  image: alpine:3.20
  interruptible: true
  timeout: 5m
  allow_failure: true
  tags:
    - qual-mcap-gcp
  variables:
    # Expect a project-level token with API scope. If not set, job will no-op.
    GITLAB_API_TOKEN: "${GITLAB_API_TOKEN}"
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event" && $CI_PROJECT_ID == $CI_MERGE_REQUEST_SOURCE_PROJECT_ID && $GITLAB_API_TOKEN
      when: on_success
    - when: never
  script:
    - |
      set -euo pipefail
      echo "Canceling redundant branch pipeline (if any) for ref=$CI_MERGE_REQUEST_SOURCE_BRANCH_NAME sha=$CI_COMMIT_SHA…"
      apk add --no-cache curl jq >/dev/null
      SRC_PROJECT_ID="${CI_MERGE_REQUEST_SOURCE_PROJECT_ID:-$CI_PROJECT_ID}"
      BRANCH="$CI_MERGE_REQUEST_SOURCE_BRANCH_NAME"
      REF_ENC="$(printf '%s' "$BRANCH" | jq -sRr @uri)"
      LIST_URL="$CI_API_V4_URL/projects/$SRC_PROJECT_ID/pipelines?ref=$REF_ENC&sha=$CI_COMMIT_SHA&per_page=100"
      if [ -z "${GITLAB_API_TOKEN:-}" ]; then
        echo "GITLAB_API_TOKEN not available; skipping cancel to avoid unauthorized API calls." && exit 0
      fi
      AUTH_HEADER="PRIVATE-TOKEN: $GITLAB_API_TOKEN"
      echo "Query: $LIST_URL (auth: PRIVATE-TOKEN)"
      STATUS="$(curl -sS -o resp.json -w '%{http_code}' -H "$AUTH_HEADER" "$LIST_URL" || echo 000)"
      case "$STATUS" in
        2*) : ;;
        *) echo "Pipelines list failed with HTTP $STATUS; body:"; cat resp.json || true; exit 0 ;;
      esac
      jq -r --arg sha "$CI_COMMIT_SHA" --arg cur "$CI_PIPELINE_ID" '
        if type=="array" then .[] else empty end
        | select(.sha == $sha)
        | select((.id|tostring) != $cur)
        | select(.status=="running" or .status=="pending")
        | .id
      ' resp.json | while read -r pid; do
        echo "Canceling pipeline $pid on branch $BRANCH (sha=$CI_COMMIT_SHA)…"
        curl -sS -X POST -H "$AUTH_HEADER" "$CI_API_V4_URL/projects/$SRC_PROJECT_ID/pipelines/$pid/cancel" >/dev/null || true
      done
      echo "Cancel step complete."

# Build images

build-rust-builder:
  extends: container-build
  stage: build
  interruptible: true
  retry:
    max: 2
    when:
      - runner_system_failure
      - api_failure
      - stuck_or_timeout_failure
  timeout: 1h
  resource_group: "rust-builder-${IMAGE_TAG_CUSTOM}"
  tags:
    - qual-mcap-gcp
  before_script:
    - |
      IMAGE_PATH_EXTRA="aifo-${IMAGE_PREFIX}-${IMAGE_PATH_EXTRA:-$TARGET}"
      # Use time-based snapshotting to reduce Kaniko memory usage
      KANIKO_BUILD_OPTIONS="--snapshotMode=time --use-new-run"
      # If TARGET_NAME or TARGET is provided, add --target attribute to build
      [ -n "${TARGET_NAME:-$TARGET}" ] && KANIKO_BUILD_OPTIONS="${KANIKO_BUILD_OPTIONS} --target ${TARGET_NAME:-$TARGET}"
      # Pass CLEAN_CARGO as a build-arg via job variable (avoids abusing KANIKO_CUSTOM_BUILD_ARGUMENTS)
      KANIKO_BUILD_OPTIONS="${KANIKO_BUILD_OPTIONS} --build-arg CLEAN_CARGO=${CLEAN_CARGO:-1}"
  variables:
    TARGET_NAME: "rust-builder"
    IMAGE_PATH_EXTRA: "rust-builder"
    KANIKO_CUSTOM_BUILD_ARGUMENTS: "REGISTRY_PREFIX=repository.migros.net/"
    CLEAN_CARGO: "1"
  # Consolidated rules: tags -> :$CI_COMMIT_TAG, default-branch changes -> :ci, branches/MRs -> per-commit <$CI_COMMIT_REF_SLUG>:$CI_COMMIT_SHA
  rules:
    # Release tags: publish builder as :$CI_COMMIT_TAG
    - if: $CI_COMMIT_TAG
      variables:
        IMAGE_TAG_CUSTOM: $CI_COMMIT_TAG
        IMAGE_TAG_CUSTOM_ONLY: "true"
    # Merge requests: publish per-commit builder under <slug>:$CI_COMMIT_SHA
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      variables:
        IMAGE_TAG_CUSTOM: $CI_COMMIT_SHA
        IMAGE_TAG_CUSTOM_ONLY: "true"
    # Nightly/scheduled refresh of stable 'ci' tag on default branch
    - if: $CI_PIPELINE_SOURCE == "schedule"
      variables:
        IMAGE_TAG_CUSTOM: "ci"
        IMAGE_TAG_CUSTOM_ONLY: "true"
    # Default branch: rebuild stable 'ci' tag only when relevant build inputs change
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      variables:
        IMAGE_TAG_CUSTOM: "ci"
        IMAGE_TAG_CUSTOM_ONLY: "true"
    # Other branches: publish per-commit builder under <slug>:$CI_COMMIT_SHA
    - if: $CI_COMMIT_BRANCH && $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH
      variables:
        IMAGE_TAG_CUSTOM: $CI_COMMIT_SHA
        IMAGE_TAG_CUSTOM_ONLY: "true"

build:
  extends: container-build
  stage: build
  interruptible: true
  timeout: 2h
  variables:
    KANIKO_CUSTOM_BUILD_ARGUMENTS: "REGISTRY_PREFIX=repository.migros.net/"
  tags:
    - qual-mcap-gcp-mem4G
  retry:
    max: 2
    when:
      - script_failure
      - runner_system_failure
      - api_failure
      - stuck_or_timeout_failure
      - unknown_failure
  needs:
    - build-rust-builder  # Wait for first build to reuse layers
  rules: *rules_build_image
  parallel:
    matrix:
      - TARGET: [ "codex","crush","aider","openhands","opencode","plandex",
                  "codex-slim","crush-slim","aider-slim","openhands-slim","opencode-slim","plandex-slim" ]

build-toolchain:
  extends: container-build
  stage: build
  interruptible: true
  timeout: 1h 30m
  tags:
    - qual-mcap-gcp-mem4G
  retry:
    max: 2
    when:
      - script_failure
      - runner_system_failure
      - api_failure
      - stuck_or_timeout_failure
      - unknown_failure
  needs:
    - build-rust-builder  # Wait for first build to reuse layers
  variables:
    IMAGE_PATH_EXTRA: "$FOLDER"
    IMAGE_PREFIX: "coder-toolchain"
    DOCKER_FILE: "toolchains/$FOLDER/Dockerfile"
    KANIKO_CUSTOM_BUILD_ARGUMENTS: "REGISTRY_PREFIX=repository.migros.net/"
  rules: *rules_build_image
  parallel:
    matrix:
      - FOLDER: [ "rust", "node", "cpp" ]

# Build macOS cross image (Kaniko) and macOS launcher

prepare-apple-sdk:
  stage: build
  image: alpine:3.20
  interruptible: true
  timeout: 15m
  tags:
    - qual-mcap-gcp
  variables:
    OSX_SDK_FILENAME: "MacOSX.sdk.tar.xz"
  script:
    - |
      set -euo pipefail
      mkdir -p ci/osx
      if [ -n "${APPLE_SDK_URL:-}" ]; then
        apk add --no-cache curl >/dev/null
        src="$(basename "$APPLE_SDK_URL")"
        tmp="ci/osx/${src}"
        echo "Downloading Apple SDK from APPLE_SDK_URL into ${tmp} ..."
        curl -fL --retry 3 --connect-timeout 10 --max-time 600 "$APPLE_SDK_URL" -o "${tmp}"
        if [ -n "${APPLE_SDK_SHA256:-}" ]; then
          echo "${APPLE_SDK_SHA256}  ${tmp}" | sha256sum -c -
        else
          echo "Warning: APPLE_SDK_SHA256 not set; skipping pre-move verification." >&2
        fi
        mv -f "${tmp}" "ci/osx/${OSX_SDK_FILENAME}"
      elif [ -n "${APPLE_SDK_BASE64:-}" ]; then
        echo "Decoding APPLE_SDK_BASE64 into ci/osx/${OSX_SDK_FILENAME} (fallback) ..."
        printf '%s' "$APPLE_SDK_BASE64" | base64 -d > "ci/osx/${OSX_SDK_FILENAME}"
      else
        echo "Error: neither APPLE_SDK_URL nor APPLE_SDK_BASE64 is set. Provide a URL (preferred) or a base64 fallback." >&2
        exit 1
      fi
      ls -lh "ci/osx/${OSX_SDK_FILENAME}"
      # Verify again against stable filename if a checksum is provided
      if [ -n "${APPLE_SDK_SHA256:-}" ]; then
        echo "${APPLE_SDK_SHA256}  ci/osx/${OSX_SDK_FILENAME}" | sha256sum -c -
      else
        echo "Warning: APPLE_SDK_SHA256 not set; computing and storing checksum only." >&2
      fi
      sha256sum "ci/osx/${OSX_SDK_FILENAME}" | tee "ci/osx/${OSX_SDK_FILENAME}.sha256" >/dev/null
      if command -v xz >/dev/null 2>&1; then xz -t "ci/osx/${OSX_SDK_FILENAME}" || echo "WARNING: xz test failed" >&2; fi
  artifacts:
    expire_in: 1 week
    paths:
      - ci/osx/${OSX_SDK_FILENAME}
      - ci/osx/${OSX_SDK_FILENAME}.sha256
  rules:
    - if: $CI_COMMIT_TAG && ($APPLE_SDK_URL || $APPLE_SDK_BASE64)
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "schedule" && ($APPLE_SDK_URL || $APPLE_SDK_BASE64)
      when: on_success
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH && ($APPLE_SDK_URL || $APPLE_SDK_BASE64)
      when: on_success
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: never
    - if: $CI_PIPELINE_SOURCE == "merge_request_event" && ($APPLE_SDK_URL || $APPLE_SDK_BASE64)
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: never

prepare-apple-sdk-skip-note:
  stage: build
  image: alpine:3.20
  interruptible: true
  timeout: 3m
  tags:
    - qual-mcap-gcp
  rules:
    - if: $APPLE_SDK_URL || $APPLE_SDK_BASE64
      when: never
    - if: $CI_COMMIT_TAG
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: on_success
  script:
    - |
      set -euo pipefail
      echo "Skipping prepare-apple-sdk: APPLE_SDK_URL and APPLE_SDK_BASE64 are both unset."
      echo "macOS cross-image build is disabled for this pipeline on branch=${CI_COMMIT_BRANCH} (ref slug: ${CI_COMMIT_REF_SLUG})."
      echo "To enable, set protected CI variables: APPLE_SDK_URL (preferred) or APPLE_SDK_BASE64."
      echo "Date: $(date -u +%Y-%m-%dT%H:%M:%SZ)"

build-macos-cross-rust-builder:
  extends: container-build
  stage: build
  interruptible: true
  timeout: 1h 30m
  resource_group: macos-cross-rust-builder
  tags:
    - qual-mcap-gcp-mem4G
  needs:
    - job: prepare-apple-sdk
      artifacts: true
  variables:
    TARGET_NAME: "macos-cross-rust-builder"
    IMAGE_PATH_EXTRA: "macos-cross-rust-builder"
    OSX_SDK_FILENAME: "MacOSX.sdk.tar.xz"
    DOCKER_FILE: "builders/macos-cross/Dockerfile"
    KANIKO_CUSTOM_BUILD_ARGUMENTS: "REGISTRY_PREFIX=repository.migros.net/"
  before_script:
    - mkdir -p ci/osx
    - |
      if [ -f "ci/osx/${OSX_SDK_FILENAME}" ]; then
        echo "Using SDK artifact: ci/osx/${OSX_SDK_FILENAME}"
      elif found="$(ls -1 ci/osx/MacOSX*.sdk.tar.* 2>/dev/null | head -n1)"; then
        echo "Found legacy SDK artifact: ${found}"
        export OSX_SDK_FILENAME="$(basename "${found}")"
      elif [ -n "${APPLE_SDK_BASE64:-}" ]; then
        echo "Decoding APPLE_SDK_BASE64 into ci/osx/${OSX_SDK_FILENAME} ..."
        /bin/sh ci/bin/decode-apple-sdk.sh
      else
        echo "Error: ci/osx/${OSX_SDK_FILENAME} not found and APPLE_SDK_BASE64 not set." >&2
        echo "Hint: ensure the 'prepare-apple-sdk' job runs in the same pipeline and is listed in needs (artifacts: true)." >&2
        exit 1
      fi
      if [ -n "${APPLE_SDK_SHA256:-}" ]; then
        echo "${APPLE_SDK_SHA256}  ci/osx/${OSX_SDK_FILENAME}" | sha256sum -c -
      elif [ -f "ci/osx/${OSX_SDK_FILENAME}.sha256" ]; then
        sha256sum -c "ci/osx/${OSX_SDK_FILENAME}.sha256"
      else
        echo "Warning: no APPLE_SDK_SHA256 provided and no .sha256 artifact found; skipping verification." >&2
      fi
    - ls -lh "ci/osx/${OSX_SDK_FILENAME}"
    - |
      # Do not mutate KANIKO_CUSTOM_BUILD_ARGUMENTS here.
      # If needed, set OSXCROSS_SDK_TARBALL as a global CI variable; the Dockerfile derives the SDK name when unset.
      :
    - |
      IMAGE_PATH_EXTRA="aifo-${IMAGE_PREFIX}-${IMAGE_PATH_EXTRA:-$TARGET}"
      # Use time-based snapshotting to reduce Kaniko memory usage
      KANIKO_BUILD_OPTIONS="--snapshotMode=time --use-new-run"
      # If TARGET_NAME or TARGET is provided, add --target attribute to build
      [ -n "${TARGET_NAME:-$TARGET}" ] && KANIKO_BUILD_OPTIONS="${KANIKO_BUILD_OPTIONS} --target ${TARGET_NAME:-$TARGET}"
  after_script:
    - |
      echo "Debug: cross-image build refs"
      echo "  CI_REGISTRY_IMAGE=$CI_REGISTRY_IMAGE"
      echo "  CI_COMMIT_REF_SLUG=$CI_COMMIT_REF_SLUG"
      echo "  IMAGE_TAG_CUSTOM=${IMAGE_TAG_CUSTOM:-unset}"
      if [ -f container_image_name_and_tag.txt ]; then
        echo "  container_image_name_and_tag.txt:"
        cat container_image_name_and_tag.txt || true
      else
        echo "  container_image_name_and_tag.txt not found."
      fi
  rules:
    - if: $CI_COMMIT_TAG
      variables:
        IMAGE_TAG_CUSTOM: $CI_COMMIT_TAG
        IMAGE_TAG_CUSTOM_ONLY: "true"
    - if: $CI_PIPELINE_SOURCE == "schedule" && ($APPLE_SDK_URL || $APPLE_SDK_BASE64)
      variables:
        IMAGE_TAG_CUSTOM: $CI_COMMIT_SHA
        IMAGE_TAG_CUSTOM_ONLY: "true"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH && ($APPLE_SDK_URL || $APPLE_SDK_BASE64)
      variables:
        IMAGE_TAG_CUSTOM: $CI_COMMIT_SHA
        IMAGE_TAG_CUSTOM_ONLY: "true"
      when: on_success
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: never
    - if: $CI_PIPELINE_SOURCE == "merge_request_event" && ($APPLE_SDK_URL || $APPLE_SDK_BASE64)
      variables:
        IMAGE_TAG_CUSTOM: $CI_COMMIT_SHA
        IMAGE_TAG_CUSTOM_ONLY: "true"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: never

build-launcher-macos:
  stage: build
  timeout: 45m
  interruptible: true
  needs:
    - build-macos-cross-rust-builder
  image: $CI_REGISTRY_IMAGE/aifo-coder-macos-cross-rust-builder:$CI_COMMIT_TAG
  tags:
    - qual-mcap-gcp
  variables:
    # Use CI-level AIFO_OTEL_ENDPOINT / AIFO_OTEL_TRANSPORT (if defined) to bake in OTLP defaults via build.rs.
    # Values should be configured as protected CI variables, not hardcoded here.
    AIFO_OTEL_ENDPOINT: "${AIFO_OTEL_ENDPOINT}"
    AIFO_OTEL_TRANSPORT: "${AIFO_OTEL_TRANSPORT}"
  script:
    - rustc --version; cargo --version
    - rustup target add aarch64-apple-darwin || true
    - cargo build --release --target aarch64-apple-darwin
    - mkdir -p dist
    - cp target/aarch64-apple-darwin/release/aifo-coder dist/aifo-coder-macos-arm64
    - file dist/aifo-coder-macos-arm64 | grep -qi 'Mach-O 64-bit arm64' || { echo "not a Mach-O arm64"; exit 2; }
    - command -v otool >/dev/null 2>&1 && otool -hv dist/aifo-coder-macos-arm64 || true
  artifacts:
    paths:
      - dist/aifo-coder-macos-arm64
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_TAG

build-launcher-macos-x86_64:
  stage: build
  timeout: 45m
  interruptible: true
  needs:
    - build-macos-cross-rust-builder
  image: $CI_REGISTRY_IMAGE/aifo-coder-macos-cross-rust-builder:$CI_COMMIT_TAG
  tags:
    - qual-mcap-gcp
  variables:
    # Use CI-level AIFO_OTEL_ENDPOINT / AIFO_OTEL_TRANSPORT (if defined) to bake in OTLP defaults via build.rs.
    # Values should be configured as protected CI variables, not hardcoded here.
    AIFO_OTEL_ENDPOINT: "${AIFO_OTEL_ENDPOINT}"
    AIFO_OTEL_TRANSPORT: "${AIFO_OTEL_TRANSPORT}"
  script:
    - rustc --version; cargo --version
    - rustup target add x86_64-apple-darwin || true
    - cargo build --release --target x86_64-apple-darwin
    - mkdir -p dist
    - cp target/x86_64-apple-darwin/release/aifo-coder dist/aifo-coder-macos-x86_64
    - file dist/aifo-coder-macos-x86_64 | grep -qi 'Mach-O 64-bit x86_64' || { echo "not a Mach-O x86_64"; exit 2; }
    - command -v otool >/dev/null 2>&1 && otool -hv dist/aifo-coder-macos-x86_64 || true
  artifacts:
    paths:
      - dist/aifo-coder-macos-x86_64
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_TAG


# Build executables

build-launcher:
  stage: build
  timeout: 45m
  interruptible: true
  retry:
    max: 2
    when:
      - runner_system_failure
      - api_failure
      - stuck_or_timeout_failure
  needs:
    - job: build-rust-builder
  image: $CI_REGISTRY_IMAGE/aifo-coder-rust-builder:$CI_COMMIT_TAG
  tags: # List of CI runners: https://wiki.migros.net/spaces/DEVOPS/pages/911828024/GitLab+CI+Runners#GitLabCIRunners-CIrunners
    - qual-mcap-gcp
  variables:
    # Use CI-level AIFO_OTEL_ENDPOINT / AIFO_OTEL_TRANSPORT (if defined) to bake in OTLP defaults via build.rs.
    # Values should be configured as protected CI variables, not hardcoded here.
    AIFO_OTEL_ENDPOINT: "${AIFO_OTEL_ENDPOINT}"
    AIFO_OTEL_TRANSPORT: "${AIFO_OTEL_TRANSPORT}"
  script:
    - cargo --version
    - rustc --version
    - echo "Building launcher (Linux native) ..."
    - cargo build --release
    - cp target/release/aifo-coder ./aifo-coder  # Copy to root folder to not have folder structure in GitLab artifacts
  artifacts:
    expire_in: 1 week
    paths:
      - aifo-coder
      - dist/aifo-coder-macos-arm64
      - dist/aifo-coder-macos-x86_64
      - README.md
      - NOTICE
      - LICENSE
  rules:
    - if: $CI_COMMIT_TAG


# Run tests

.rust-ci-base:
  stage: test
  interruptible: true
  retry:
    max: 2
    when:
      - runner_system_failure
      - api_failure
      - stuck_or_timeout_failure
  timeout: 30m
  image: $RB_IMAGE
  # Use optional needs so default-branch 'ci' builder can be change-skipped while downstream jobs still run.
  needs:
    - job: build-rust-builder
      optional: true
  tags:
    - qual-mcap-gcp
  variables:
    RUST_BACKTRACE: "1"
    AIFO_SUPPORT_ANIMATE: "0"
    CARGO_HOME: "$CI_PROJECT_DIR/.cargo"
    ARGS_NEXTEST: '--no-fail-fast --status-level=fail --hide-progress-bar --cargo-quiet --profile ci'
    GIT_LFS_SKIP_SMUDGE: "1"
    AIFO_SUPPORT_SKIP_GREEN: "1"
    AIFO_CODER_TEST_DISABLE_DOCKER: "1"
    # CI spec v1: disable incremental to reduce target churn; use sccache for compiled artifacts
    CARGO_INCREMENTAL: "0"
    RUSTC_WRAPPER: "sccache"
    SCCACHE_DIR: "$CI_PROJECT_DIR/.cache/sccache"
  cache:
    key:
      files:
        - .cargo/config.toml
    policy: pull
    # Do not cache target; narrow to registry/git sources and sccache directory
    paths:
      - .cargo/registry
      - .cargo/git
      - .cache/sccache
  before_script:
    - echo "Running CI job (base)…"
    - rustc --version
    - cargo --version
    - cargo nextest --version || true
  after_script:
    - |
      echo "CI validation: sccache stats and cache footprints"
      echo "UTC now: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
      if command -v sccache >/dev/null 2>&1; then
        sccache --show-stats || true
      else
        echo "sccache not found"
      fi
      if [ -n "${SCCACHE_DIR:-}" ]; then
        echo "SCCACHE_DIR: $SCCACHE_DIR"
        du -sh "$SCCACHE_DIR" 2>/dev/null || true
        echo "sccache file count:"
        find "$SCCACHE_DIR" -type f 2>/dev/null | wc -l || true
      fi
      if [ -d ".cargo/registry" ]; then
        echo ".cargo/registry file count:"
        find .cargo/registry -type f | wc -l || true
      fi
      if [ -d ".cargo/git" ]; then
        echo ".cargo/git file count:"
        find .cargo/git -type f | wc -l || true
      fi
  rules: &rb_image_rules
    - if: $CI_COMMIT_TAG
      when: never
    # Merge requests: use per-commit builder image
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      variables:
        RB_IMAGE: "$CI_REGISTRY_IMAGE/aifo-coder-rust-builder/$CI_COMMIT_REF_SLUG:$CI_COMMIT_SHA"
        AIFO_CODER_TEST_CPP_IMAGE: "$CI_REGISTRY_IMAGE/aifo-coder-toolchain-cpp:$CI_COMMIT_SHA"
        AIFO_CODER_TEST_RUST_IMAGE: "$CI_REGISTRY_IMAGE/aifo-coder-toolchain-rust:$CI_COMMIT_SHA"
    # Non-default branches: use per-commit builder image
    - if: $CI_COMMIT_BRANCH && $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH
      variables:
        RB_IMAGE: "$CI_REGISTRY_IMAGE/aifo-coder-rust-builder/$CI_COMMIT_REF_SLUG:$CI_COMMIT_SHA"
        AIFO_CODER_TEST_CPP_IMAGE: "$CI_REGISTRY_IMAGE/aifo-coder-toolchain-cpp:$CI_COMMIT_SHA"
        AIFO_CODER_TEST_RUST_IMAGE: "$CI_REGISTRY_IMAGE/aifo-coder-toolchain-rust:$CI_COMMIT_SHA"
    # Default branch: use stable 'ci' tag
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      variables:
        RB_IMAGE: "$CI_REGISTRY_IMAGE/aifo-coder-rust-builder:ci"
        AIFO_CODER_TEST_CPP_IMAGE: "$CI_REGISTRY_IMAGE/aifo-coder-toolchain-cpp:ci"
        AIFO_CODER_TEST_RUST_IMAGE: "$CI_REGISTRY_IMAGE/aifo-coder-toolchain-rust:ci"

lint:
  extends: .rust-ci-base
  script:
    - echo "Running lint job…"
    - make lint

otel-golden-stdout:
  extends: .rust-ci-base
  script:
    - echo "Running OpenTelemetry golden stdout and smoke tests…"
    - sh ci/otel-golden-stdout.sh

test:
  extends: .rust-ci-base
  needs:
    - job: build-rust-builder
      optional: true
    - lint
  tags:
    - qual-mcap-gcp
  artifacts:
    when: always
    expire_in: 1 week
    reports:
      junit: target/nextest/ci/junit.xml
    paths:
      - target/nextest/ci/junit.xml
  script:
    - echo "Running test job…"
    - mkdir -p target/nextest/ci
    - make test
  rules:
    - if: $CI_COMMIT_TAG
      when: never
    - if: $CI_PIPELINE_SOURCE == "merge_request_event" || $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: never
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH && $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH && $CI_OPEN_MERGE_REQUESTS == null
      variables:
        RB_IMAGE: "$CI_REGISTRY_IMAGE/aifo-coder-rust-builder/$CI_COMMIT_REF_SLUG:$CI_COMMIT_SHA"
      when: on_success

test-e2e:
  extends: .rust-ci-base
  stage: test
  interruptible: true
  timeout: 90m
  tags:
    - qual-mcap-gcp
  variables:
    AIFO_CODER_TEST_DISABLE_DOCKER: "0"
  needs:
    - job: build-rust-builder
      optional: true
    - lint
  script:
    - echo "Running integration tests (via Makefile) ..."
    - make test-integration-suite
    - echo "Running E2E tests (via Makefile) ..."
    - make test-acceptance-suite
  artifacts:
    when: always
    expire_in: 1 week
    reports:
      junit: target/nextest/ci/junit.xml
    paths:
      - target/nextest/ci/junit.xml
  rules:
    - if: $CI_COMMIT_TAG
      when: never
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      variables:
        RB_IMAGE: "$CI_REGISTRY_IMAGE/aifo-coder-rust-builder/$CI_COMMIT_REF_SLUG:$CI_COMMIT_SHA"
      when: on_success
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      variables:
        RB_IMAGE: "$CI_REGISTRY_IMAGE/aifo-coder-rust-builder:ci"
      when: on_success

test-macos-cross-image:
  stage: test
  interruptible: true
  timeout: 45m
  needs:
    - job: build-macos-cross-rust-builder
  image: $CROSS_IMAGE_PATH:$CROSS_IMAGE_TAG
  tags:
    - qual-mcap-gcp
  variables:
    RUST_BACKTRACE: "1"
    CARGO_HOME: "$CI_PROJECT_DIR/.cargo"
    RUSTC_WRAPPER: "sccache"
    SCCACHE_DIR: "$CI_PROJECT_DIR/.cache/sccache"
    CARGO_INCREMENTAL: "0"
    CARGO_TERM_COLOR: "always"
  cache:
    key:
      files:
        - .cargo/config.toml
    policy: pull
    paths:
      - .cargo/registry
      - .cargo/git
      - .cache/sccache
  script:
    - export PATH="/usr/local/cargo/bin:/usr/local/rustup/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"; export RUSTC="/usr/local/cargo/bin/rustc"; unset LD; rustc --version; sccache --version || true; sccache --show-stats || true; /usr/local/cargo/bin/cargo --version || true
    - /usr/local/cargo/bin/cargo nextest -V || /usr/local/cargo/bin/cargo install cargo-nextest --locked
    - /usr/local/cargo/bin/cargo nextest run --color always --run-ignored ignored-only --profile ci --no-fail-fast --status-level=fail --hide-progress-bar -E 'test(/^e2e_macos_cross_/)'
  rules:
    # Run on release tags: plain path + tag
    - if: $CI_COMMIT_TAG
      variables:
        CROSS_IMAGE_PATH: "$CI_REGISTRY_IMAGE/aifo-coder-macos-cross-rust-builder"
        CROSS_IMAGE_TAG: "$CI_COMMIT_TAG"
      when: on_success
    # Scheduled pipelines: require Apple SDK secrets; namespaced path
    - if: $CI_PIPELINE_SOURCE == "schedule" && ($APPLE_SDK_URL || $APPLE_SDK_BASE64)
      variables:
        CROSS_IMAGE_PATH: "$CI_REGISTRY_IMAGE/aifo-coder-macos-cross-rust-builder"
        CROSS_IMAGE_TAG: "$CI_COMMIT_SHA"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    # Default branch: require Apple SDK secrets; namespaced path
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH && ($APPLE_SDK_URL || $APPLE_SDK_BASE64)
      variables:
        CROSS_IMAGE_PATH: "$CI_REGISTRY_IMAGE/aifo-coder-macos-cross-rust-builder"
        CROSS_IMAGE_TAG: "$CI_COMMIT_SHA"
      when: on_success
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: never
    # Merge requests: require Apple SDK secrets; namespaced path
    - if: $CI_PIPELINE_SOURCE == "merge_request_event" && ($APPLE_SDK_URL || $APPLE_SDK_BASE64)
      variables:
        CROSS_IMAGE_PATH: "$CI_REGISTRY_IMAGE/aifo-coder-macos-cross-rust-builder/$CI_COMMIT_REF_SLUG"
        CROSS_IMAGE_TAG: "$CI_COMMIT_SHA"
      when: on_success
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: never

lint-dockerfiles:
  stage: test
  image: repository.migros.net/hadolint/hadolint:2.12.0-debian
  interruptible: true
  timeout: 10m
  tags:
    - qual-mcap-gcp
  script:
    - echo "Linting Dockerfiles with hadolint (advisory)..."
    - |
      FILES=""
      [ -f Dockerfile ] && FILES="$FILES Dockerfile"
      [ -f toolchains/rust/Dockerfile ] && FILES="$FILES toolchains/rust/Dockerfile"
      [ -f toolchains/node/Dockerfile ] && FILES="$FILES toolchains/node/Dockerfile"
      [ -f toolchains/cpp/Dockerfile ] && FILES="$FILES toolchains/cpp/Dockerfile"
      [ -f builders/macos-cross/Dockerfile ] && FILES="$FILES builders/macos-cross/Dockerfile"
      if [ -n "$FILES" ]; then
        hadolint --format gitlab_codeclimate $FILES > gl-code-quality-report.json || true
      else
        echo "No Dockerfiles found to lint."
      fi
  artifacts:
    when: always
    reports:
      codequality: gl-code-quality-report.json
    paths:
      - gl-code-quality-report.json
  rules:
    - if: $CI_COMMIT_TAG
      when: never
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: on_success
    - if: $CI_COMMIT_BRANCH
      changes:
        - Dockerfile
        - toolchains/**/Dockerfile
        - .gitlab-ci.yml
  allow_failure: true

# Multi-arch publish using Docker Buildx (manifest with amd64 + arm64) - Disabled for now (no DinD)

publish-multiarch:
  stage: release
  image: docker:24
  services:
    - name: docker:24-dind
      alias: docker
  interruptible: true
  timeout: 2h
  tags:
    - qual-mcap-gcp
  variables:
    DOCKER_HOST: "tcp://docker:2375"
    DOCKER_TLS_CERTDIR: ""
    DOCKER_BUILDKIT: "1"
    PLATFORMS: "linux/amd64,linux/arm64"
    PUSH: "1"
    REGISTRY: "$CI_REGISTRY_IMAGE"
    TAG: "$CI_COMMIT_TAG"
    RUST_TOOLCHAIN_TAG: "$CI_COMMIT_TAG"
    NODE_TOOLCHAIN_TAG: "$CI_COMMIT_TAG"
    CPP_TOOLCHAIN_TAG: "$CI_COMMIT_TAG"
  before_script:
    - docker version || true
    - docker buildx version || true
    - docker login "$CI_REGISTRY" -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD"
    - docker run --privileged --rm tonistiigi/binfmt --install amd64,arm64
    - docker buildx create --name ci-builder --use
    - docker buildx inspect --bootstrap
  script:
    - make publish
    - for img in codex crush aider openhands opencode plandex codex-slim crush-slim aider-slim openhands-slim opencode-slim plandex-slim; do docker buildx imagetools inspect "$CI_REGISTRY_IMAGE/aifo-coder-$img:$CI_COMMIT_TAG" || true; done
    - for tc in rust node cpp; do docker buildx imagetools inspect "$CI_REGISTRY_IMAGE/aifo-coder-toolchain-$tc:$CI_COMMIT_TAG" || true; done
  rules:
    - if: $CI_COMMIT_TAG
      when: never

# Create launcher release

publish-release:
  stage: release
  timeout: 45m
  interruptible: true
  retry:
    max: 2
    when:
      - runner_system_failure
      - api_failure
      - stuck_or_timeout_failure
  needs:
    - job: build-launcher
      artifacts: true
    - job: build-launcher-macos
      artifacts: true
    - job: build-launcher-macos-x86_64
      artifacts: true
  tags: # List of CI runners: https://wiki.migros.net/spaces/DEVOPS/pages/911828024/GitLab+CI+Runners#GitLabCIRunners-CIrunners
    - qual-mcap-gcp
  image: repository.migros.net/registry.gitlab.com/gitlab-org/release-cli:v0.24.0
  script:
    - |
      set -euo pipefail
      echo "Preparing release artifacts..."
      # Flatten macOS binaries to the job root
      cp dist/aifo-coder-macos-arm64 .
      cp dist/aifo-coder-macos-x86_64 .
      # Rename Linux binary for clarity
      mv aifo-coder aifo-coder-linux-x86_64
      # Create per-OS archives including docs
      tar -czf aifo-coder-linux-x86_64.tar.gz \
        aifo-coder-linux-x86_64 README.md NOTICE LICENSE
      tar -czf aifo-coder-macos.tar.gz \
        aifo-coder-macos-arm64 aifo-coder-macos-x86_64 README.md NOTICE LICENSE
      echo "Artifacts ready:"
      ls -lh aifo-coder-linux-x86_64 aifo-coder-macos-arm64 aifo-coder-macos-x86_64
      ls -lh aifo-coder-linux-x86_64.tar.gz aifo-coder-macos.tar.gz
      ls -lh README.md NOTICE LICENSE
      echo
      echo "NOTE: CI does not sign or notarize macOS artifacts. To publish signed/notarized macOS zips:"
      echo "  1) On macOS, run: make release-macos-binary-signed"
      echo "  2) Upload dist/*.zip to the GitLab Package Registry under ${CI_COMMIT_TAG}"
      echo "  3) Run the manual job: publish-macos-signed-zips"
  artifacts:
    expire_in: 1 week
    paths:
      - aifo-coder-linux-x86_64
      - aifo-coder-macos-arm64
      - aifo-coder-macos-x86_64
      - aifo-coder-linux-x86_64.tar.gz
      - aifo-coder-macos.tar.gz
      - README.md
      - NOTICE
      - LICENSE
      - docs/
  release:
    tag_name: $CI_COMMIT_TAG
    name: "Release $CI_COMMIT_TAG"
    description: "$CI_COMMIT_MESSAGE"
    assets:
      links:
        - name: aifo-coder-linux-x86_64.tar.gz
          url: $CI_JOB_URL/artifacts/file/aifo-coder-linux-x86_64.tar.gz
        - name: aifo-coder-macos.tar.gz
          url: $CI_JOB_URL/artifacts/file/aifo-coder-macos.tar.gz
        - name: aifo-coder-linux-x86_64
          url: $CI_JOB_URL/artifacts/file/aifo-coder-linux-x86_64
        - name: aifo-coder-macos-arm64
          url: $CI_JOB_URL/artifacts/file/aifo-coder-macos-arm64
        - name: aifo-coder-macos-x86_64
          url: $CI_JOB_URL/artifacts/file/aifo-coder-macos-x86_64
  rules:
    - if: $CI_COMMIT_TAG

publish-macos-signed-zips:
  stage: release
  image: alpine:3.20
  interruptible: true
  timeout: 15m
  tags:
    - qual-mcap-gcp
  needs:
    - publish-release
  rules:
    - if: $CI_COMMIT_TAG
      when: on_success
  variables:
    # Requires a project/group token with api scope and permission to edit releases.
    # Use a protected/masked CI variable.
    GITLAB_API_TOKEN: "${GITLAB_API_TOKEN}"
  script:
    - |
      set -euo pipefail
      apk add --no-cache curl jq >/dev/null
      if [ -z "${GITLAB_API_TOKEN:-}" ]; then
        echo "GITLAB_API_TOKEN not set; skipping signed macOS zip link attachment."
        exit 0
      fi

      ARM_ZIP="${SIGNED_MACOS_ARM64_ZIP}"
      X86_ZIP="${SIGNED_MACOS_X86_64_ZIP}"

      echo "Expecting signed zip filenames:"
      echo "  ${ARM_ZIP}"
      echo "  ${X86_ZIP}"
      echo "Package registry base:"
      echo "  ${PACKAGE_REGISTRY_URL}"

      # Validate that the signed zips exist in the Generic Package Registry (HEAD).
      auth_hdr="PRIVATE-TOKEN: ${GITLAB_API_TOKEN}"
      arm_url="${PACKAGE_REGISTRY_URL}/${ARM_ZIP}"
      x86_url="${PACKAGE_REGISTRY_URL}/${X86_ZIP}"

      echo "Checking package registry objects..."
      arm_status="$(curl -sS -o /dev/null -w '%{http_code}' -I -H "${auth_hdr}" "${arm_url}" || echo 000)"
      x86_status="$(curl -sS -o /dev/null -w '%{http_code}' -I -H "${auth_hdr}" "${x86_url}" || echo 000)"

      if [ "${arm_status}" != "200" ] && [ "${x86_status}" != "200" ]; then
        echo "No signed macOS zip artifacts found in package registry for tag ${CI_COMMIT_TAG}; skipping."
        exit 0
      fi

      # Create (or update) release asset links pointing at the package registry URLs.
      release_url="${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/releases/${CI_COMMIT_TAG}"
      echo "Fetching existing release assets..."
      curl -sS -H "${auth_hdr}" "${release_url}" > release.json
      existing="$(jq -r '.assets.links[].url // empty' release.json | tr '\n' ' ')"

      add_link() {
        name="$1"
        url="$2"
        if echo "${existing}" | grep -Fq -- "${url}"; then
          echo "Release link already present: ${name} -> ${url}"
          return 0
        fi
        echo "Adding release link: ${name} -> ${url}"
        curl -sS -X POST -H "${auth_hdr}" \
          --data-urlencode "name=${name}" \
          --data-urlencode "url=${url}" \
          "${release_url}/assets/links" >/dev/null
      }

      if [ "${arm_status}" = "200" ]; then
        add_link "${ARM_ZIP}" "${arm_url}"
      else
        echo "arm64 signed zip not found (HTTP ${arm_status}); skipping link."
      fi

      if [ "${x86_status}" = "200" ]; then
        add_link "${X86_ZIP}" "${x86_url}"
      else
        echo "x86_64 signed zip not found (HTTP ${x86_status}); skipping link."
      fi

      echo "Done."
